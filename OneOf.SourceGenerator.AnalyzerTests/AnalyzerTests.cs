using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace OneOf.SourceGenerator.AnalyzerTests
{
    public class AnalyzerTests
    {
        [Fact]
        public void GenerateOneOfAttribute()
        {
            const string expectedCode = @"// <auto-generated />
using System;

#pragma warning disable 1591

namespace OneOf
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class GenerateOneOfAttribute : Attribute
    {
    }
}
";
            AssertCorrectSourceCodeIsGeneratedWithNoDiagnostics(string.Empty, expectedCode, "GenerateOneOfAttribute.g.cs", 2);
        }

        [Fact]
        public void GeneratesPublicClass()
        {
            const string input = @"
using OneOf;

namespace Foo
{
    [GenerateOneOf]
    public partial class StringOrNumber : OneOfBase<string, int, uint> { }
}
";

            const string expectedCode = @"// <auto-generated />
#pragma warning disable 1591

namespace Foo
{
    partial class StringOrNumber
    {
        public StringOrNumber(OneOf.OneOf<string, int, uint> _) : base(_) { }

        public static implicit operator StringOrNumber(string _) => new StringOrNumber(_);
        public static explicit operator string(StringOrNumber _) => _.AsT0;

        public static implicit operator StringOrNumber(int _) => new StringOrNumber(_);
        public static explicit operator int(StringOrNumber _) => _.AsT1;

        public static implicit operator StringOrNumber(uint _) => new StringOrNumber(_);
        public static explicit operator uint(StringOrNumber _) => _.AsT2;
    }
}";

            AssertCorrectSourceCodeIsGeneratedWithNoDiagnostics(input, expectedCode, "Foo_StringOrNumber.g.cs");
        }

        [Fact]
        public void GeneratesInternalClass()
        {
            const string input = @"
using OneOf;

namespace Foo
{
    [GenerateOneOf]
    internal partial class StringOrNumber : OneOfBase<string, int, uint> { }
}
";

            const string expectedCode = @"// <auto-generated />
#pragma warning disable 1591

namespace Foo
{
    partial class StringOrNumber
    {
        public StringOrNumber(OneOf.OneOf<string, int, uint> _) : base(_) { }

        public static implicit operator StringOrNumber(string _) => new StringOrNumber(_);
        public static explicit operator string(StringOrNumber _) => _.AsT0;

        public static implicit operator StringOrNumber(int _) => new StringOrNumber(_);
        public static explicit operator int(StringOrNumber _) => _.AsT1;

        public static implicit operator StringOrNumber(uint _) => new StringOrNumber(_);
        public static explicit operator uint(StringOrNumber _) => _.AsT2;
    }
}";

            AssertCorrectSourceCodeIsGeneratedWithNoDiagnostics(input, expectedCode, "Foo_StringOrNumber.g.cs");
        }

        [Fact]
        public void GeneratesInternalClassWithoutExplicitVisibility()
        {
            const string input = @"
using OneOf;

namespace Foo
{
    [GenerateOneOf]
    partial class StringOrNumber : OneOfBase<string, int, uint> { }
}
";

            const string expectedCode = @"// <auto-generated />
#pragma warning disable 1591

namespace Foo
{
    partial class StringOrNumber
    {
        public StringOrNumber(OneOf.OneOf<string, int, uint> _) : base(_) { }

        public static implicit operator StringOrNumber(string _) => new StringOrNumber(_);
        public static explicit operator string(StringOrNumber _) => _.AsT0;

        public static implicit operator StringOrNumber(int _) => new StringOrNumber(_);
        public static explicit operator int(StringOrNumber _) => _.AsT1;

        public static implicit operator StringOrNumber(uint _) => new StringOrNumber(_);
        public static explicit operator uint(StringOrNumber _) => _.AsT2;
    }
}";

            AssertCorrectSourceCodeIsGeneratedWithNoDiagnostics(input, expectedCode, "Foo_StringOrNumber.g.cs");
        }
        
        [Fact]
        public void Class_Must_Be_Top_Level()
        {
            const string input = @"
using OneOf;

namespace Foo
{
    public static class A
    {
        [GenerateOneOf]
        public partial class StringOrNumber : OneOfBase<string, int> { }
    }
}
";

            AssertDiagnosticErrorIsReturned(input, GeneratorDiagnosticDescriptors.TopLevelError.Id);
        }

        [Fact]
        public void Cannot_Use_Generator_With_Object_type()
        {
            const string input = @"
using OneOf;

namespace Foo
{
    [GenerateOneOf]
    public partial class ObjectOrNumber : OneOfBase<object, int> { }
}
";
            AssertDiagnosticErrorIsReturned(input, GeneratorDiagnosticDescriptors.ObjectIsOneOfType.Id);
        }

        [Fact]
        public void Class_Must_Be_Derived_From_OneOfBase()
        {
            const string input = @"
using OneOf;

namespace Foo
{
    [GenerateOneOf]
    public partial class ObjectOrNumber : MyClass { }

    public class MyClass
    {
    }
}
";
            AssertDiagnosticErrorIsReturned(input, GeneratorDiagnosticDescriptors.WrongBaseType.Id);
        }

        [Fact]
        public void User_Defined_Conversions_To_Or_From_An_Interface_Are_Not_Allowed()
        {
            const string input = @"
using OneOf;

namespace Foo
{
    [GenerateOneOf]
    public partial class ObjectOrNumber : OneOfBase<IFoo, int> { }

    public interface IFoo
    {
    }
}
";
            AssertDiagnosticErrorIsReturned(input, GeneratorDiagnosticDescriptors.UserDefinedConversionsToOrFromAnInterfaceAreNotAllowed.Id);
        }
        
        [Fact]
        public void GeneratesClassWithConflictingNamespaces()
        {
            const string input = $@"
using OneOf;
using Bar;

namespace Foo.Bar 
{{
    public class Class1
    {{
    }}
}}

namespace Bar 
{{
    public class Class2
    {{
    }}
}}

namespace Foo
{{
    [GenerateOneOf]
    partial class FooBar : OneOfBase<global::Foo.Bar.Class1, Class2> {{ }}
}}
";

            const string expectedCode = @"// <auto-generated />
#pragma warning disable 1591

namespace Foo
{
    partial class FooBar
    {
        public FooBar(OneOf.OneOf<global::Foo.Bar.Class1, global::Bar.Class2> _) : base(_) { }

        public static implicit operator FooBar(global::Foo.Bar.Class1 _) => new FooBar(_);
        public static explicit operator global::Foo.Bar.Class1(FooBar _) => _.AsT0;

        public static implicit operator FooBar(global::Bar.Class2 _) => new FooBar(_);
        public static explicit operator global::Bar.Class2(FooBar _) => _.AsT1;
    }
}";

            AssertCorrectSourceCodeIsGeneratedWithNoDiagnostics(input, expectedCode, "Foo_FooBar.g.cs");
        }

        private static void AssertCorrectSourceCodeIsGeneratedWithNoDiagnostics(string inputSource, string expectedCode, string generatedFileName, int expectedCompilationFileCount = 3)
        {
            var parsedAttribute = CSharpSyntaxTree.ParseText(expectedCode);

            var inputCompilation = CreateCompilation(inputSource);

            GeneratorDriver driver = CSharpGeneratorDriver.Create(new OneOfGenerator());

            driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);

            Assert.True(diagnostics.IsEmpty);

            Assert.Equal(expectedCompilationFileCount, outputCompilation.SyntaxTrees.Count());

            Assert.Empty(outputCompilation.GetDiagnostics());

            var compiledAttribute = outputCompilation.SyntaxTrees.Single(e => e.FilePath.Contains(generatedFileName));

            Assert.True(parsedAttribute.IsEquivalentTo(compiledAttribute));

            Assert.True(outputCompilation.GetDiagnostics().IsEmpty);
        }

        private static void AssertDiagnosticErrorIsReturned(string inputSource, string diagnosticId)
        {
            var inputCompilation = CreateCompilation(inputSource);

            GeneratorDriver driver = CSharpGeneratorDriver.Create(new OneOfGenerator());

            driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out _, out var diagnostics);

            Assert.Contains(diagnostics, d => d.Id == diagnosticId && d.Severity == DiagnosticSeverity.Error);
        }

        private static Compilation CreateCompilation(string source)
        {
            var references = new List<MetadataReference>
            {
                MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location),
                MetadataReference.CreateFromFile(typeof(OneOfBase<>).GetTypeInfo().Assembly.Location),
                MetadataReference.CreateFromFile(AppDomain.CurrentDomain.GetAssemblies().Single(a => a.GetName().Name == "netstandard").Location)
            };

            //https://github.com/dotnet/roslyn/issues/49498#issuecomment-734452762
            foreach (var assembly in Assembly.GetEntryAssembly()!.GetReferencedAssemblies())
            {
                references.Add(MetadataReference.CreateFromFile(Assembly.Load(assembly).Location));
            }

            return CSharpCompilation.Create("compilation", new[] { CSharpSyntaxTree.ParseText(source) }, references, new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
        }
    }
}