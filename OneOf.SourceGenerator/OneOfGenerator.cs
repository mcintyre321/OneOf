using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace OneOf.SourceGenerator
{
    [Generator]
    public class OneOfGenerator : IIncrementalGenerator
    {
        private const string AttributeName = "GenerateOneOfAttribute";
        private const string AttributeNamespace = "OneOf";

        private static readonly string _attributeText = $@"// <auto-generated />
using System;

#pragma warning disable 1591

namespace {AttributeNamespace}
{{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class {AttributeName} : Attribute
    {{
    }}
}}
";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
                $"{AttributeName}.g.cs",
                SourceText.From(_attributeText, Encoding.UTF8)));

            IncrementalValuesProvider<ClassToGenerate?> classesToGenerate = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    $"{AttributeNamespace}.{AttributeName}",
                    predicate: (node, _) => IsCandidateForGeneration(node),
                    transform: GetClassToGenerate)
                .Where(static m => m is not null);

            context.RegisterSourceOutput(classesToGenerate,
                static (spc, classToGenerate) => Execute(in classToGenerate, spc));
        }

        private static bool IsCandidateForGeneration(SyntaxNode node)
            => node is ClassDeclarationSyntax classSyntax && classSyntax.AttributeLists.Count > 0;

        private static void Execute(in ClassToGenerate? classToGenerate, SourceProductionContext context)
        {
            if (classToGenerate is { } validClass)
            {
                if (validClass.Error is not null)
                {
                    context.ReportDiagnostic(validClass.Error);
                    return;
                }

                var result = GetClassCode(in validClass);
                context.AddSource($"{validClass.Namespace}_{validClass.Name}.g.cs", SourceText.From(result, Encoding.UTF8));
            }
        }

        private static ClassToGenerate? GetClassToGenerate(GeneratorAttributeSyntaxContext context, CancellationToken ct)
        {
            if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
            {
                return null;
            }

            // Check to see if the class has the attribute we're looking for, otherwise return null and do nothing
            if (!classSymbol.GetAttributes().Any(a => a.AttributeClass?.Name == AttributeName
                    && a.AttributeClass?.ContainingNamespace.Name == AttributeNamespace))
            {
                return null;
            }

            ct.ThrowIfCancellationRequested();

            if (ClassHasErrors(classSymbol, context, out ClassToGenerate? classWithError))
            {
                return classWithError;
            }

            IEnumerable<(ITypeParameterSymbol param, ITypeSymbol arg)> paramArgPairs =
                classSymbol.BaseType!.TypeParameters.Zip(classSymbol.BaseType.TypeArguments, (param, arg) => (param, arg));

            return new ClassToGenerate(
                classSymbol.Name,
                classSymbol.ContainingNamespace.ToDisplayString(),
                classSymbol.TypeArguments,
                classSymbol.BaseType!.TypeArguments,
                paramArgPairs);
        }

        private static bool ClassHasErrors(INamedTypeSymbol classSymbol, GeneratorAttributeSyntaxContext context, out ClassToGenerate? classWithError)
        {
            classWithError = null;

            if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
            {
                classWithError = CreateError(GeneratorDiagnosticDescriptors.TopLevelError, context.TargetNode.GetLocation(), classSymbol.Name);
                return true;
            }

            if (classSymbol.BaseType is null || classSymbol.BaseType.Name != "OneOfBase" || classSymbol.BaseType.ContainingNamespace.ToString() != AttributeNamespace)
            {
                classWithError = CreateError(GeneratorDiagnosticDescriptors.WrongBaseType, context.TargetNode.GetLocation(), classSymbol.Name);
                return true;
            }

            foreach (ITypeSymbol typeSymbol in classSymbol.BaseType!.TypeArguments)
            {
                if (typeSymbol.Name == nameof(Object))
                {
                    classWithError = CreateError(GeneratorDiagnosticDescriptors.ObjectIsOneOfType, context.TargetNode.GetLocation(), classSymbol.Name);
                    return true;
                }

                if (typeSymbol.TypeKind == TypeKind.Interface)
                {
                    classWithError = CreateError(GeneratorDiagnosticDescriptors.UserDefinedConversionsToOrFromAnInterfaceAreNotAllowed,
                        context.TargetNode.GetLocation(), classSymbol.Name);
                    return true;
                }
            }

            return false;
        }

        private static ClassToGenerate CreateError(DiagnosticDescriptor descriptor, Location location, string name)
            => new(Diagnostic.Create(descriptor, location, name, DiagnosticSeverity.Error));

        private static string GetGenericPart(ImmutableArray<ITypeSymbol> typeArguments) =>
            string.Join(", ", typeArguments.Select(x => x.ToDisplayString()));

        private static string? GetOpenGenericPart(ImmutableArray<ITypeSymbol> typeArguments)
        {
            if (!typeArguments.Any())
            {
                return null;
            }

            return $"<{GetGenericPart(typeArguments)}>";
        }

        private static string GetClassCode(in ClassToGenerate classToGenerate)
        {
            string constructor = $"public {classToGenerate.Name}(OneOf.OneOf<{GetGenericPart(classToGenerate.OneOfBaseTypeArguments)}> _) : base(_) {{ }}";

            string classNameWithGenericTypes = $"{classToGenerate.Name}{GetOpenGenericPart(classToGenerate.TypeArguments)}";

            StringBuilder sbParamArgPairs = new();
            foreach ((ITypeParameterSymbol param, ITypeSymbol arg) in classToGenerate.ParamArgPairs)
            {
                sbParamArgPairs.Append($@"
        public static implicit operator {classNameWithGenericTypes}({arg.ToDisplayString()} _) => new {classNameWithGenericTypes}(_);
        public static explicit operator {arg.ToDisplayString()}({classNameWithGenericTypes} _) => _.As{param.Name};
");
            }

            return $@"// <auto-generated />
#pragma warning disable 1591

namespace {classToGenerate.Namespace}
{{
    partial class {classNameWithGenericTypes}
    {{
        {constructor}
        {sbParamArgPairs}
    }}
}}
";
        }

        internal sealed class ClassToGenerate
        {
            public ClassToGenerate(
                string name,
                string @namespace,
                ImmutableArray<ITypeSymbol> typeArguments,
                ImmutableArray<ITypeSymbol> oneOfBaseTypeArguments,
                IEnumerable<(ITypeParameterSymbol param, ITypeSymbol arg)> paramArgPairs)
            {
                Name = name;
                Namespace = @namespace;
                TypeArguments = typeArguments;
                OneOfBaseTypeArguments = oneOfBaseTypeArguments;
                ParamArgPairs = paramArgPairs;
            }

            public ClassToGenerate(Diagnostic error)
                : this("", "", default, default, new List<(ITypeParameterSymbol param, ITypeSymbol arg)>())
                => Error = error;

            public string Name { get; }
            public string Namespace { get; }
            public ImmutableArray<ITypeSymbol> TypeArguments { get; }
            public ImmutableArray<ITypeSymbol> OneOfBaseTypeArguments { get; }
            public IEnumerable<(ITypeParameterSymbol param, ITypeSymbol arg)> ParamArgPairs { get; }
            public Diagnostic? Error { get; }
        }
    }
}