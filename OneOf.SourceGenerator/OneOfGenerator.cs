using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace OneOf.SourceGenerator
{
    [Generator]
    public class OneOfGenerator : ISourceGenerator
    {
        private const string AttributeName = "GenerateOneOfAttribute";
        private const string AttributeNamespace = "OneOf";

        private readonly string _attributeText = $@"// <auto-generated />
using System;

#pragma warning disable 1591

namespace {AttributeNamespace}
{{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class {AttributeName} : Attribute
    {{
    }}
}}
";

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not OneOfSyntaxReceiver receiver)
            {
                return;
            }

            Compilation compilation = context.Compilation;

            INamedTypeSymbol? attributeSymbol =
                compilation.GetTypeByMetadataName($"{AttributeNamespace}.{AttributeName}");

            if (attributeSymbol is null)
            {
                return;
            }

            List<(INamedTypeSymbol, Location?)> namedTypeSymbols = new();
            foreach (ClassDeclarationSyntax classDeclaration in receiver.CandidateClasses)
            {
                SemanticModel model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                INamedTypeSymbol? namedTypeSymbol = model.GetDeclaredSymbol(classDeclaration);

                AttributeData? attributeData = namedTypeSymbol?.GetAttributes().FirstOrDefault(ad =>
                    ad.AttributeClass?.Equals(attributeSymbol, SymbolEqualityComparer.Default) != false);

                if (attributeData is not null)
                {
                    namedTypeSymbols.Add((namedTypeSymbol!,
                        attributeData.ApplicationSyntaxReference?.GetSyntax().GetLocation()));
                }
            }

            foreach ((INamedTypeSymbol namedSymbol, Location? attributeLocation) in namedTypeSymbols)
            {
                string? classSource = ProcessClass(namedSymbol, context, attributeLocation);

                if (classSource is null)
                {
                    continue;
                }

                context.AddSource($"{namedSymbol.ContainingNamespace}_{namedSymbol.Name}.g.cs", classSource);
            }
        }

        private static string? ProcessClass(INamedTypeSymbol classSymbol, GeneratorExecutionContext context, Location? attributeLocation)
        {
            attributeLocation ??= Location.None;

            if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
            {
                CreateDiagnosticError(GeneratorDiagnosticDescriptors.TopLevelError);
                return null;
            }

            if (classSymbol.BaseType is null || classSymbol.BaseType.Name != "OneOfBase" || classSymbol.BaseType.ContainingNamespace.ToString() != "OneOf")
            {
                CreateDiagnosticError(GeneratorDiagnosticDescriptors.WrongBaseType);
                return null;
            }

            if (classSymbol.DeclaredAccessibility != Accessibility.Public)
            {
                CreateDiagnosticError(GeneratorDiagnosticDescriptors.ClassIsNotPublic);
                return null;
            }

            ImmutableArray<ITypeSymbol> typeArguments = classSymbol.BaseType.TypeArguments;

            foreach (ITypeSymbol typeSymbol in typeArguments)
            {
                if (typeSymbol.Name == nameof(Object))
                {
                    CreateDiagnosticError(GeneratorDiagnosticDescriptors.ObjectIsOneOfType);
                    return null;
                }

                if (typeSymbol.TypeKind == TypeKind.Interface)
                {
                    CreateDiagnosticError(GeneratorDiagnosticDescriptors.UserDefinedConversionsToOrFromAnInterfaceAreNotAllowed);
                    return null;
                }
            }

            return GenerateClassSource(classSymbol, classSymbol.BaseType.TypeParameters, typeArguments);

            void CreateDiagnosticError(DiagnosticDescriptor descriptor)
                => context.ReportDiagnostic(Diagnostic.Create(descriptor, attributeLocation, classSymbol.Name, DiagnosticSeverity.Error));
        }

        private static string GenerateClassSource(INamedTypeSymbol classSymbol,
            ImmutableArray<ITypeParameterSymbol> typeParameters, ImmutableArray<ITypeSymbol> typeArguments)
        {
            IEnumerable<(ITypeParameterSymbol param, ITypeSymbol arg)> paramArgPairs =
                typeParameters.Zip(typeArguments, (param, arg) => (param, arg));

            string oneOfGenericPart = GetGenericPart(typeArguments);

            string classNameWithGenericTypes = $"{classSymbol.Name}{GetOpenGenericPart(classSymbol)}";

            StringBuilder source = new($@"// <auto-generated />
#pragma warning disable 1591

namespace {classSymbol.ContainingNamespace.ToDisplayString()}
{{
    public partial class {classNameWithGenericTypes}");

            source.Append($@"
    {{
        public {classSymbol.Name}(OneOf.OneOf<{oneOfGenericPart}> _) : base(_) {{ }}
");

            foreach ((ITypeParameterSymbol param, ITypeSymbol arg) in paramArgPairs)
            {
                source.Append($@"
        public static implicit operator {classNameWithGenericTypes}({arg.ToDisplayString()} _) => new {classNameWithGenericTypes}(_);
        public static explicit operator {arg.ToDisplayString()}({classNameWithGenericTypes} _) => _.As{param.Name};
");
            }

            source.Append(@"    }
}");
            return source.ToString();
        }

        private static string GetGenericPart(ImmutableArray<ITypeSymbol> typeArguments) =>
            string.Join(", ", typeArguments.Select(x => x.ToDisplayString()));

        private static string? GetOpenGenericPart(INamedTypeSymbol classSymbol)
        {
            if (!classSymbol.TypeArguments.Any())
            {
                return null;
            }

            return $"<{GetGenericPart(classSymbol.TypeArguments)}>";
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForPostInitialization(ctx =>
                ctx.AddSource($"{AttributeName}.g.cs", _attributeText));
            context.RegisterForSyntaxNotifications(() => new OneOfSyntaxReceiver());
        }

        internal class OneOfSyntaxReceiver : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is ClassDeclarationSyntax { AttributeLists: { Count: > 0 } } classDeclarationSyntax
                    && classDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword))
                {
                    CandidateClasses.Add(classDeclarationSyntax);
                }
            }
        }
    }
}
